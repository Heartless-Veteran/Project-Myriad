package com.heartlessveteran.myriad.navigation

import android.net.Uri
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner
import org.robolectric.annotation.Config

/**
 * Unit tests for NavigationService route parsing functionality.
 *
 * These tests verify that all route parsing methods correctly parse
 * the route strings generated by the corresponding Destination.createRoute() methods.
 */
@RunWith(RobolectricTestRunner::class)
@Config(sdk = [28])
class NavigationServiceTest {
    private lateinit var navigationService: NavigationService

    @Before
    fun setUp() {
        navigationService = NavigationService()
    }

    @Test
    fun `parseRoute should return null for null input`() {
        val result = navigationService.parseRoute(null)
        assertNull("parseRoute should return null for null input", result)
    }

    @Test
    fun `parseRoute should return null for empty route`() {
        val result = navigationService.parseRoute("")
        assertNull("parseRoute should return null for empty route", result)
    }

    @Test
    fun `parseRoute should return Home for home route`() {
        val result = navigationService.parseRoute("home")
        assertEquals("Should parse home route correctly", Destination.Home, result)
    }

    @Test
    fun `parseRoute should return MangaLibrary for manga library route`() {
        val result = navigationService.parseRoute("manga_library")
        assertEquals("Should parse manga library route correctly", Destination.MangaLibrary, result)
    }

    @Test
    fun `parseRoute should return AnimeLibrary for anime library route`() {
        val result = navigationService.parseRoute("anime_library")
        assertEquals("Should parse anime library route correctly", Destination.AnimeLibrary, result)
    }

    @Test
    fun `parseRoute should return Browse for browse route`() {
        val result = navigationService.parseRoute("browse")
        assertEquals("Should parse browse route correctly", Destination.Browse, result)
    }

    @Test
    fun `parseRoute should return AICore for ai core route`() {
        val result = navigationService.parseRoute("ai_core")
        assertEquals("Should parse AI core route correctly", Destination.AICore, result)
    }

    // Reading Route Tests
    @Test
    fun `parseRoute should parse reading route with manga ID only`() {
        val mangaId = "test-manga-123"
        val route = "reading/${Uri.encode(mangaId)}"

        val result = navigationService.parseRoute(route)

        assertTrue("Should parse reading route", result is Destination.Reading)
        val readingDest = result as Destination.Reading
        assertEquals("Manga ID should match", mangaId, readingDest.mangaId)
        assertNull("Chapter ID should be null", readingDest.chapterId)
        assertEquals("Page should be 0", 0, readingDest.page)
    }

    @Test
    fun `parseRoute should parse reading route with manga ID and chapter ID`() {
        val mangaId = "test-manga-123"
        val chapterId = "chapter-456"
        val route = "reading/${Uri.encode(mangaId)}/${Uri.encode(chapterId)}"

        val result = navigationService.parseRoute(route)

        assertTrue("Should parse reading route", result is Destination.Reading)
        val readingDest = result as Destination.Reading
        assertEquals("Manga ID should match", mangaId, readingDest.mangaId)
        assertEquals("Chapter ID should match", chapterId, readingDest.chapterId)
        assertEquals("Page should be 0", 0, readingDest.page)
    }

    @Test
    fun `parseRoute should parse reading route with page parameter`() {
        val mangaId = "test-manga-123"
        val chapterId = "chapter-456"
        val page = 5
        val route = "reading/${Uri.encode(mangaId)}/${Uri.encode(chapterId)}?page=$page"

        val result = navigationService.parseRoute(route)

        assertTrue("Should parse reading route", result is Destination.Reading)
        val readingDest = result as Destination.Reading
        assertEquals("Manga ID should match", mangaId, readingDest.mangaId)
        assertEquals("Chapter ID should match", chapterId, readingDest.chapterId)
        assertEquals("Page should match", page, readingDest.page)
    }

    @Test
    fun `parseRoute should handle special characters in reading route`() {
        val mangaId = "manga with spaces & symbols"
        val chapterId = "chapter/special"
        val route = "reading/${Uri.encode(mangaId)}/${Uri.encode(chapterId)}"

        val result = navigationService.parseRoute(route)

        assertTrue("Should parse reading route with special characters", result is Destination.Reading)
        val readingDest = result as Destination.Reading
        assertEquals("Manga ID should be decoded correctly", mangaId, readingDest.mangaId)
        assertEquals("Chapter ID should be decoded correctly", chapterId, readingDest.chapterId)
    }

    // Watching Route Tests
    @Test
    fun `parseRoute should parse watching route with anime ID only`() {
        val animeId = "test-anime-789"
        val route = "watching/${Uri.encode(animeId)}"

        val result = navigationService.parseRoute(route)

        assertTrue("Should parse watching route", result is Destination.Watching)
        val watchingDest = result as Destination.Watching
        assertEquals("Anime ID should match", animeId, watchingDest.animeId)
        assertNull("Episode ID should be null", watchingDest.episodeId)
        assertEquals("Timestamp should be 0", 0L, watchingDest.timestamp)
    }

    @Test
    fun `parseRoute should parse watching route with timestamp`() {
        val animeId = "test-anime-789"
        val episodeId = "episode-123"
        val timestamp = 12345L
        val route = "watching/${Uri.encode(animeId)}/${Uri.encode(episodeId)}?timestamp=$timestamp"

        val result = navigationService.parseRoute(route)

        assertTrue("Should parse watching route", result is Destination.Watching)
        val watchingDest = result as Destination.Watching
        assertEquals("Anime ID should match", animeId, watchingDest.animeId)
        assertEquals("Episode ID should match", episodeId, watchingDest.episodeId)
        assertEquals("Timestamp should match", timestamp, watchingDest.timestamp)
    }

    // Manga Detail Route Tests
    @Test
    fun `parseRoute should parse manga detail route`() {
        val mangaId = "manga-detail-123"
        val sourceId = "mangadex"
        val route = "manga-detail/${Uri.encode(mangaId)}/${Uri.encode(sourceId)}"

        val result = navigationService.parseRoute(route)

        assertTrue("Should parse manga detail route", result is Destination.MangaDetail)
        val mangaDetailDest = result as Destination.MangaDetail
        assertEquals("Manga ID should match", mangaId, mangaDetailDest.mangaId)
        assertEquals("Source ID should match", sourceId, mangaDetailDest.sourceId)
    }

    @Test
    fun `parseRoute should parse manga detail route without source`() {
        val mangaId = "manga-detail-123"
        val route = "manga-detail/${Uri.encode(mangaId)}"

        val result = navigationService.parseRoute(route)

        assertTrue("Should parse manga detail route", result is Destination.MangaDetail)
        val mangaDetailDest = result as Destination.MangaDetail
        assertEquals("Manga ID should match", mangaId, mangaDetailDest.mangaId)
        assertNull("Source ID should be null", mangaDetailDest.sourceId)
    }

    // Anime Detail Route Tests
    @Test
    fun `parseRoute should parse anime detail route`() {
        val animeId = "anime-detail-456"
        val sourceId = "crunchyroll"
        val route = "anime-detail/${Uri.encode(animeId)}/${Uri.encode(sourceId)}"

        val result = navigationService.parseRoute(route)

        assertTrue("Should parse anime detail route", result is Destination.AnimeDetail)
        val animeDetailDest = result as Destination.AnimeDetail
        assertEquals("Anime ID should match", animeId, animeDetailDest.animeId)
        assertEquals("Source ID should match", sourceId, animeDetailDest.sourceId)
    }

    // Search Route Tests
    @Test
    fun `parseRoute should parse search route with all parameters`() {
        val query = "one piece"
        val type = ContentType.MANGA
        val source = "mangadex"
        val route = "search?query=${Uri.encode(query)}&type=${type.name}&source=${Uri.encode(source)}"

        val result = navigationService.parseRoute(route)

        assertTrue("Should parse search route", result is Destination.Search)
        val searchDest = result as Destination.Search
        assertEquals("Query should match", query, searchDest.query)
        assertEquals("Type should match", type, searchDest.type)
        assertEquals("Source should match", source, searchDest.source)
    }

    @Test
    fun `parseRoute should parse search route with minimal parameters`() {
        val route = "search"

        val result = navigationService.parseRoute(route)

        assertTrue("Should parse basic search route", result is Destination.Search)
        val searchDest = result as Destination.Search
        assertEquals("Query should be empty", "", searchDest.query)
        assertEquals("Type should be ALL", ContentType.ALL, searchDest.type)
        assertNull("Source should be null", searchDest.source)
    }

    @Test
    fun `parseRoute should handle invalid content type in search route`() {
        val query = "test"
        val route = "search?query=${Uri.encode(query)}&type=INVALID"

        val result = navigationService.parseRoute(route)

        assertTrue("Should parse search route with invalid type", result is Destination.Search)
        val searchDest = result as Destination.Search
        assertEquals("Query should match", query, searchDest.query)
        assertEquals("Type should default to ALL", ContentType.ALL, searchDest.type)
    }

    // Settings Route Tests
    @Test
    fun `parseRoute should parse settings route without section`() {
        val route = "settings"

        val result = navigationService.parseRoute(route)

        assertTrue("Should parse basic settings route", result is Destination.Settings)
        val settingsDest = result as Destination.Settings
        assertEquals("Section should be GENERAL", SettingsSection.GENERAL, settingsDest.section)
    }

    @Test
    fun `parseRoute should parse settings route with section`() {
        val section = SettingsSection.READING
        val route = "settings/${section.name.lowercase()}"

        val result = navigationService.parseRoute(route)

        assertTrue("Should parse settings route with section", result is Destination.Settings)
        val settingsDest = result as Destination.Settings
        assertEquals("Section should match", section, settingsDest.section)
    }

    @Test
    fun `parseRoute should return null for invalid settings section`() {
        val route = "settings/invalid_section"

        val result = navigationService.parseRoute(route)

        assertNull("Should return null for invalid settings section", result)
    }

    // Error Cases
    @Test
    fun `parseRoute should return null for invalid route`() {
        val result = navigationService.parseRoute("invalid/route/pattern")
        assertNull("Should return null for invalid route", result)
    }

    @Test
    fun `parseRoute should return null for malformed reading route`() {
        val result = navigationService.parseRoute("reading/")
        assertNull("Should return null for malformed reading route", result)
    }

    @Test
    fun `parseRoute should return null for malformed manga detail route`() {
        val result = navigationService.parseRoute("manga-detail/")
        assertNull("Should return null for malformed manga detail route", result)
    }

    // Round-trip Tests - verify that createRoute() and parseRoute() are inverse operations
    @Test
    fun `round trip test for reading route`() {
        val original = Destination.Reading("test-manga", "test-chapter", 5)
        val route = Destination.Reading.createRoute(original.mangaId, original.chapterId, original.page)
        val parsed = navigationService.parseRoute(route)

        assertEquals("Round trip should preserve Reading destination", original, parsed)
    }

    @Test
    fun `round trip test for watching route`() {
        val original = Destination.Watching("test-anime", "test-episode", 12345L)
        val route = Destination.Watching.createRoute(original.animeId, original.episodeId, original.timestamp)
        val parsed = navigationService.parseRoute(route)

        assertEquals("Round trip should preserve Watching destination", original, parsed)
    }

    @Test
    fun `round trip test for manga detail route`() {
        val original = Destination.MangaDetail("test-manga", "test-source")
        val route = Destination.MangaDetail.createRoute(original.mangaId, original.sourceId)
        val parsed = navigationService.parseRoute(route)

        assertEquals("Round trip should preserve MangaDetail destination", original, parsed)
    }

    @Test
    fun `round trip test for search route`() {
        val original = Destination.Search("test query", ContentType.ANIME, "test-source")
        val route = Destination.Search.createRoute(original.query, original.type, original.source)
        val parsed = navigationService.parseRoute(route)

        assertEquals("Round trip should preserve Search destination", original, parsed)
    }

    @Test
    fun `round trip test for settings route`() {
        val original = Destination.Settings(SettingsSection.AI)
        val route = Destination.Settings.createRoute(original.section)
        val parsed = navigationService.parseRoute(route)

        assertEquals("Round trip should preserve Settings destination", original, parsed)
    }
}
